# -*- coding: utf-8 -*-
"""ANÁLISIS DE DATOS - CEPRE - MODELO PREDICTIVO ANÁLISIS DE ÉXITO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FSfK118bYHvtFQlXcJ8WWhWxj6zH-ryW

# MODELO PREDICTIVO - ANÁLISIS DE ÉXITO
"""

# CARGA DE DATASET Y LIBRERÍAS
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, roc_auc_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import FunctionTransformer


df = pd.read_csv('/content/sample_data/Datos_abiertos_cepre.csv')
df

# AGREGAR COLUMNA 'CICLO' PARA CONSIDERAR EL DATO EN UNA SOLA COLUMNA
df['CICLO'] = df[['ANIO_POSTULA', 'CICLO_POSTULA']].astype(str).agg('-'.join, axis=1)
df['CICLO']

# AGREGAR COLUMNA 'EDAD' RESTANDO EL AÑO DE POSTULACIÓN Y AÑO DE NACIMIENTO
df['EDAD'] = df['ANIO_POSTULA'] - df['ANIO_NACIMIENTO']
df['EDAD']

# UN PARÁMETRO A CONSIDERAR EN EL ANÁLISIS Y MODELO PREDICTIVO ES LA 'PREPARACION' QUE LOS ALUMNOS CON DESEOS DE INGRESAR A LA UNI DEBEN CONSIDERAR PARA CUMPLIR TAL OBJETIVO
# GENERALMENTE, AL EGRESAR DEL COLEGIO, LOS ALUMNOS OPTAN POR MATRICULARSE EN ACADEMIAS PRE UNIVERSITARIAS ASÍ COMO EN LA CEPRE-UNI, POR LO QUE SE ASUME PARA EL ANÁLISIS QUE A MAYOR PREPARACIÓN, MÁS POSIBILIDADES DEL ALUMNA DE INGRESAR A LA UNI
# AGREGAR COLUMNA 'PREPARACION' RESTANDO AÑO DE POSTULACIÓN Y AÑO DE EGRESO DEL COLEGIO, EXISTEN UN PAR DE CASOS EN LOS QUE ALUMNOS QUE AÚN NO HABÍAN EGRESADO DEL COLEGIO, SE MATRICULARON EN LA CEPRE-UNI, POR LO QUE ESTE NO GENERARÁ INCONSISTENCIA EN LOS DATOS
df['PREPARACION'] = df['ANIO_POSTULA'] - df['COLEGIO_ANIO_EGRESO']
df['PREPARACION']

# AGREGAR COLUMNA 'COLEGIO_DEPA_PROV', SE CONSIDERA LA CONCATENACIÓN PARA DE AMBAS COLUMNAS PARA LUEGO AGRUPAR LOS DATOS POR PROVINCIAS-DEPARTAMENTOS Y DIFERENCIARLOS ADEMÁS DE LAS PROVINCIAS METROPOLINADA DE LIMA Y LA PROVINCIA CONSTITUCIONAL DEL CALLAO, DONDE EN ESTOS ÚLTIMOS SE TIENE MAYOR CANTIDAD DE REGISTROS
df['COLEGIO_DEPA_PROV'] = df[['COLEGIO_DEPA', 'COLEGIO_PROV']].astype(str).agg('-'.join, axis=1)
df['COLEGIO_DEPA_PROV']

# REASIGNAMOS EL NOMBRE DE LA COLUMNA 'IDHASH' POR EL DE 'ALUMNOS' Y VALIDAMOS LA INFORMACIÓN DEL DF CON LA ACTUALIZACIÓN HASTA EL MOMENTO
df.rename(columns={'IDHASH': 'ALUMNOS'}, inplace=True)
df.info()

# DEL ANÁLISIS REALIZADO POR DISTRIBUCIÓN GEOGRÁFICA ENTRE LOS DATOS DOMICILIO, COLEGIO Y NACIMIENTO, SE OBTUVO QUE EL DATO CON MAYOR PRECISIÓN Y CRITERIO ES EL DE COLEGIO, POR LO QUE SE UTILIZARÁ ESE DATOS PARA LA ZONIFICACIÓN DE PROVINCIAS.
# PARA IDENTIFICAR Y ANALIZAR DATOS DE ALUMNOS CON DOMICILIO, COLEGIO Y NACIMIENTO, SE AGRUPARÁN LOS DEPARTAMENTOS POR REGIONES, 'NO', 'NE', 'NC', 'SC', 'SE', 'SO', 'LC', 'I'
# EN LOS DATOS DE COLEGIO NO SE PRESENTAN REGISTROS QUE PERTENEZCAN A UN COLEGIO EN EL EXTRANJERO [(I)NTERNACIONAL]

# DELIMITACIÓN DE REGIONES GEOGRÁFICAMENTE SEGÚN CRITERIO DE CERCANÍA DE DEPARTAMENTOS
data=[
       ['TUMBES', 'PIURA', 'LAMBAYEQUE', 'CAJAMARCA'],     #NO
       ['AMAZONAS', 'LORETO', 'SAN MARTIN', 'UCAYALI'],    #NE
       ['LA LIBERTAD', 'ANCASH', 'HUANUCO', 'PASCO'],      #NC
       ['JUNIN', 'HUANCAVELICA', 'AYACUCHO', 'APURIMAC'],  #SC
       ['CUSCO', 'MADRE DE DIOS', 'PUNO'],                 #SE
       ['ICA', 'AREQUIPA', 'MOQUEGUA', 'TACNA'],           #SO
       ['CALLAO', 'LIMA']                                  #LC
     ]

def asignar_region(departamento_provincia):
  spl = departamento_provincia.split('-')
  if spl[0] in data[0]:
    return 'NO'
  elif spl[0] in data[1]:
    return 'NE'
  elif spl[0] in data[2]:
    return 'NC'
  elif spl[0] in data[3]:
    return 'SC'
  elif spl[0] in data[4]:
    return 'SE'
  elif spl[0] in data[5]:
    return 'SO'
  elif spl[0] in data[6]:
    if spl[1] in data[6]:
      return 'LC'
    else:
      return 'SC'
  else:
    return 'I'

df['COLEGIO_ZONA'] = df['COLEGIO_DEPA_PROV'].apply(asignar_region)

# PARA EL ANÁLISIS Y MODELO PREDICTIVO, SE CONSIDERA ÚNICAMENTE ALUMNOS INGRESANTES POR LA MODALIDAD INGRESO DIRECTO PARA REFORZAR EL ANÁLISIS CONCENTRADO EN INFORMACIÓN EXCLUSIVA DE LA CEPRE
# POR LO QUE SE CONSIDERA QUE LOS ALUMNOS QUE INGRESARON POR ORDINARIO, PREVIAMENTE NO INGRESARON POR CEPRE, ENTONCES:

# DEFINIR LAS CONDICIONES
condicion = (df['INGRESO']=='SI') & (df['MODO_INGRESO'] == 'ORDINARIO')

# REEMPLAZAR LOS VALORES DE 'INGRESO' BAJO ESTA CONDICIÓN
df.loc[condicion, 'INGRESO'] = 'NO'

dff = df

# CON LA DATA PREPARADA PARA APLICARLA EN EL MODELAMIENTO, SE EJECUTAN LOS SIGUIENTES PASOS:

# PASO 1: PREPROCESAR LOS DATOS Y ENTRENAR MODELO

# SELECCIONAR LAS CARACTERÍSTICAS RELEVANTES
features = ['SEXO', 'CALIF_FINAL', 'PREPARACION',
            'CICLO', 'EDAD', 'COLEGIO_ZONA']

# VARIABLE OBJETIVO
target = 'INGRESO'

# FILTRAR COLUMNAS NECESARIAS
X = dff[features]
y = dff[target]

# DEFINIR EL PREPROCESADOR
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), ['EDAD', 'CALIF_FINAL','PREPARACION']),
        ('cat', OneHotEncoder(handle_unknown='ignore'), ['SEXO', 'CICLO', 'COLEGIO_ZONA'])
    ])

# CREAR PIPELINE QUE INCLUYA EL PROCESADOR Y EL MODELO
model_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', LogisticRegression())
])

# DIVIDIR LOS DATOS EN CONJUNTO DE ENTRENAMIENTO Y PRUEBA
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# ENTRENAR MODELO
model_pipeline.fit(X_train, y_train)

# PREDECIR CON DATOS TEST
y_pred = model_pipeline.predict(X_test)

# EVALUDAR EL RENDIMIENTO DEL MODELO
print("Exactitud:", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))
y_pred_prob = model_pipeline.predict_proba(X_test)[:, 1]
print("AUC-ROC:", roc_auc_score(y_test, y_pred_prob))

# Paso 2: PREDECIR CON VALORES NUEVOS

# NUEVOS DATOS PARA PREDECIR
df_nuevos = pd.DataFrame({
    'SEXO': ['FEMENINO', 'FEMENINO', 'FEMENINO', 'MASCULINO'],
    'EDAD': [21, 19, 18, 18],
    'CALIF_FINAL': [14, 13.4, 15, 16],
    'PREPARACION': [4, 2, 2, 2],
    'COLEGIO_ZONA': ['LC', 'SO', 'NC', 'LC'],
    'CICLO': ['2017-1', '2025-2', '2018-2', '2010-1']
})

# SE CONDIFICAN Y ESTANDARIZAN LOS NUEVOS DATOS
df_nuevos_encoded = preprocessor.transform(df_nuevos)
predicciones = model_pipeline.named_steps['model'].predict(df_nuevos_encoded)

# ALMACENAR LAS PREDICCIONES
df_nuevos['PREDICCIÓN'] = predicciones

df_nuevos

# OBTENER EL MODELO DE REGRESIÓN LOGÍSTICA DEL PIPELINE
modelo_logistico = model_pipeline.named_steps['model']

# OBTENER COEFICIENTES DEL MODELO
coeficientes = modelo_logistico.coef_[0]

nombres_caracteristicas = preprocessor.get_feature_names_out()

# CREAR DF PARA VISUALIZAR LOS COEFICIENTES JUNTO A LOS NOMBRES DE LAS CARACTERÍSTICAS
coef_df = pd.DataFrame({'Característica': nombres_caracteristicas, 'Peso': coeficientes})

# ORDENAR EL VALOR ABSOLUTO DEL PESO
coef_df['Peso_absoluto'] = coef_df['Peso'].abs()
coef_df = coef_df.sort_values(by='Peso_absoluto', ascending=False)

coef_df

# DESCARGAR EL MODELO PREDICTIVO ENTRENADO PARA UTILIZARLO EN EL TABLERO DE CONTROL POWER BI

import pickle

# GUARDAR EN UN ARCHIVO .PKL
with open('modelo_pipeline.pkl', 'wb') as file:
    pickle.dump(model_pipeline, file)